---
title: |
    | KID
    | Function
      
author: "Fabian Blasch"
date: "`r format(Sys.Date(), format = '%d.%m.%Y')`"
output: pdf_document
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(echo = TRUE,
                      message = FALSE,
                      # cache = TRUE ,
                      fig.width = 4,
                      fig.height = 3, 
                      fig.align = "center")
```

## Packages

```{r, results = "hide"}
# Packages
get.package <- function(package){
  
  lapply(package, \(x){
    # check if packages are installed and if not install them
    if(!require(x, character.only = T)){
       install.packages(x)
    }
    # call package
    library(x, character.only = T)
  })
    
}

# exec
get.package(c("png", "jpeg", "tabulizer", "pdftools", "raster", "rgdal", "sp", 
              "cluster"))




# since I will use Map() / lapply() alot for plotting I will wrap them in invisible()
invis.Map <- function(f, ...) invisible(Map(f, ...))
invis.lapply <- function(x, f, ...) invisible(lapply(x, f, ...))
```

## Actual SRRI 

We can obtain the actual SRRI from the file name. Later this data will be utilized to evaluate 
the classification accuracy of the applied methods.

```{r, fig.height = 5, fig.width = 7}
# set
setwd("C:/Users/blasc/OneDrive/Documents/GitHub/KID/KIDs")

# files
file_names <- list.files(pattern = ".pdf", recursive = T)

# create df
dat.valid.SRRI <- as.data.frame(cbind("KID" = file_names,
                        "SRRI" = sapply(strsplit(sapply(strsplit(file_names, "_", fixed = T), 
                                        function(x) x[length(x)]), ".", fixed = T), "[", 1)))

# split first col 
dat.valid.SRRI[, "KAG"] <- sapply(strsplit(dat.valid.SRRI[, 1], "/"), "[", 1)
dat.valid.SRRI[, "KID"] <- sapply(strsplit(dat.valid.SRRI[, 1], "/"), "[", 2)

# order
dat.valid.SRRI <- dat.valid.SRRI[, c(3, 1, 2)]

# glimpse
head(dat.valid.SRRI, 7)

# dim
dim(dat.valid.SRRI)

# Hist
hist(as.numeric(dat.valid.SRRI[, "SRRI"]), breaks = 10, main = "SRRI", col = 4, xlab = "")
```
## Shade Color

To extract the SRRI the following colors are required and need to be converted to
HEX.

```{r}
# set
setwd("C:/Users/blasc/OneDrive/Documents/GitHub/KID/KIDs/Auxiliary")

# import
dat.col.KAG <- read.table(list.files(pattern = "RGB"), 
                          col.names = c("KAG", "R", "G", "B"))

# add hex
sapply(as.data.frame(t(dat.col.KAG[, -1])), 
       function(x) do.call(rgb, as.list(c(x, maxColorValue = 255)))) -> HEX

# bind
dat.col.KAG <- cbind(dat.col.KAG, "HEX" = HEX)

# display
dat.col.KAG
```
## SRRI Extraction Function

Given a KID document this function aims to extract the SRRI from the standard graph (usually) located on the first of two pages.

```{r}
# source function
source("C:/Users/blasc/OneDrive/Documents/GitHub/KID/Code/Functions/SRRI_ext.R")
```

## Tests

Starting with one KAG.

### Erste

```{r, fig.width = 15, fig.height = 17}
# set wd to file that contains 
setwd("C:/Users/blasc/OneDrive/Documents/GitHub/KID/KIDs")

# safe dirs 
dirs <- list.dirs()[-c(1, 4)] # remove hardcode later

# colors 
col <- dat.col.KAG[order(dat.col.KAG[, "KAG"]), c("KAG", "HEX")]
col[5, 1] <- "Kepler Fonds"

# test Erste 
Map(function(x, y){
  
  # set
  {setwd("C:/Users/blasc/OneDrive/Documents/GitHub/KID/KIDs")
   setwd(x)

  # ,pdfs
  file_nom <- list.files(pattern = ".pdf")}
  
   # FUN over all .pdfs
  lapply(file_nom, function(z){
    SRRI_ext(doc = z, col = y)
  })

  
}, dirs[3], col[3, 2]) -> erste.test


# extracted SRRI
cbind(dat.valid.SRRI[dat.valid.SRRI[, "KAG"] == "Erste", ], 
      "Extracted" = sapply(erste.test[[1]], "[[", 2)) -> res

par(mfrow = c(3, 4))

# plot
invis.Map(function(x, y, z, l, k){
  
  {plot(x[, 1], x[, 2], col = x[, ncol(x)], pch = 19, main = paste("Predicted:", z, "| Actual:", l))
  abline(v = y, col = "red", lwd = 2)
  lapply(k, function(x) abline(v = x, col = "grey", lwd = 2, lty = 2))}
  
}, lapply(erste.test[[1]], "[[", 3), sapply(erste.test[[1]], "[[", 4), res[, 4], res[, 3],
   lapply(erste.test[[1]], "[[", 5))
```

In the case of Erste the SRRI extraction works perfectly. Now the remaining KAGs will be examined.

```{r, message = FALSE, error = FALSE, warning = FALSE}
# store Errors 
utils::capture.output(

  # Map over dirs 
  Map(function(x, y){
    
    # set
    {setwd("C:/Users/blasc/OneDrive/Documents/GitHub/KID/KIDs")
     setwd(x)
  
    # ,pdfs
    file_nom <- list.files(pattern = ".pdf")}
    
     # lapply over all .pdfs
    lapply(file_nom, function(z){
      
      # extract and error handle
      try(SRRI_ext(doc = z, col = y), silent = F)
      
    })
    
  }, dirs, col[, 2]) -> test

, type = "message")

# error index
lapply(test, function(x){
  
  # error ind
  which(sapply(x, class) == "try-error")
  
}) -> err.tmp

# retrieve error throwing funds with ind
do.call(rbind, Map(function(x, y, z){
  
  if(length(y) > 0){
    
    {setwd("C:/Users/blasc/OneDrive/Documents/GitHub/KID/KIDs")
     setwd(z)

    # .pdfs
    file_nom <- list.files(pattern = ".pdf")}
    
    # subset
    cbind(rep(z, length(y)),
          file_nom[y], 
          sapply(x[y], "[", 1))
    
  } else {
   cbind(NA, NA, "No errros.")
  }

}, test, err.tmp, dirs)) -> dat.err
```

Now that we have identified all KIDs for which the extraction failed, we can proceed to see if the classification was correct for the remaining kids. 

```{r, , fig.width = 15, fig.height = 17}
# Plot
Map(function(x, y){

  sapply(y, function(x){
    # cond
    if(class(x) == "try-error"){
      return(NA)
    } else {
      x[[2]]
    }
  }) -> tmp
  
  # match
  cbind(dat.valid.SRRI[dat.valid.SRRI[, "KAG"] == x, ],
        "Extracted" = tmp)


}, col[, 1], test) -> tef



par(mfrow = c(3, 4))

# plot

# over KAGs
invis.Map(function(m, n){
  
  # arrange
  par(mfrow = c(ceiling(length(m) / 4), 4))
  
  # over KIDs
  invis.Map(function(x, y, z, k){
  
    if(class(x) == "try-error"){
      
      # plot empty for KIDs that remain unclassified for now 
      plot(NULL, xlim = c(0, 1), ylim = c(0, 1), main = "Error")
      
    } else {
      # build tmp vars for plotting 
      plot.coo <- x[[3]]
      med <- x[[4]]
      scal <- x[[5]]
      pred <- y
      act <- z
      fund <- k
    
      # plot
      plot(plot.coo[, 1], plot.coo[, 2], col = plot.coo[, ncol(plot.coo)], pch = 19, 
           main = paste(fund, "\n", "Predicted:", pred, "| Actual:", act))
      
      # median
      abline(v = med, col = "red", lty = 1, lwd = 2)
      
      # Scale
      lapply(scal, function(s) abline(v = s, col = "grey", lwd = 2, lty = 2))
      }
  
    },m , n[, 4], n[, 3], n[, 1])
  
}, test, tef)
```








